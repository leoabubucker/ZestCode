\doxysection{x\+Semaphore\+Create\+Binary\+Static}
\hypertarget{group__x_semaphore_create_binary_static}{}\label{group__x_semaphore_create_binary_static}\index{xSemaphoreCreateBinaryStatic@{xSemaphoreCreateBinaryStatic}}
semphr. h 
\begin{DoxyPre}sem\_t xSemaphoreCreateBinaryStatic( static\_sem\_s\_t *pxSemaphoreBuffer )\end{DoxyPre}


Creates a new binary semaphore instance, and returns a handle by which the new semaphore can be referenced.

NOTE\+: In many usage scenarios it is faster and more memory efficient to use a direct to task notification in place of a binary semaphore! \href{http://www.freertos.org/RTOS-task-notifications.html}{\texttt{ http\+://www.\+freertos.\+org/\+RTOS-\/task-\/notifications.\+html}}

Internally, within the Free\+RTOS implementation, binary semaphores use a block of memory, in which the semaphore structure is stored. If a binary semaphore is created using \doxylink{group__apix_ga83c9a6c93e3bfce8f36e3f32a6dc8c4b}{sem\+\_\+binary\+\_\+create()} then the required memory is automatically dynamically allocated inside the \doxylink{group__apix_ga83c9a6c93e3bfce8f36e3f32a6dc8c4b}{sem\+\_\+binary\+\_\+create()} function. (see \href{http://www.freertos.org/a00111.html}{\texttt{ http\+://www.\+freertos.\+org/a00111.\+html}}). If a binary semaphore is created using x\+Semaphore\+Create\+Binary\+Static() then the application writer must provide the memory. x\+Semaphore\+Create\+Binary\+Static() therefore allows a binary semaphore to be created without using any dynamic memory allocation.

This type of semaphore can be used for pure synchronisation between tasks or between an interrupt and a task. The semaphore need not be given back once obtained, so one task/interrupt can continuously \textquotesingle{}give\textquotesingle{} the semaphore while another continuously \textquotesingle{}takes\textquotesingle{} the semaphore. For this reason this type of semaphore does not use a priority inheritance mechanism. For an alternative that does use priority inheritance see \doxylink{group__c-rtos_ga475d096afa3abcc9a276ca9fa54bafdf}{mutex\+\_\+create()}.


\begin{DoxyParams}{Parameters}
{\em px\+Semaphore\+Buffer} & Must point to a variable of type static\+\_\+sem\+\_\+s\+\_\+t, which will then be used to hold the semaphore\textquotesingle{}s data structure, removing the need for the memory to be allocated dynamically.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
If the semaphore is created then a handle to the created semaphore is returned. If px\+Semaphore\+Buffer is NULL then NULL is returned.
\end{DoxyReturn}
Example usage\+: 
\begin{DoxyPre}
sem\_t xSemaphore = NULL;
static\_sem\_s\_t xSemaphoreBuffer;

void vATask( void * pvParameters )
\{
   // Semaphore cannot be used before a call to \doxylink{group__apix_ga83c9a6c93e3bfce8f36e3f32a6dc8c4b}{sem\_binary\_create()}.
   // The semaphore's data structures will be placed in the xSemaphoreBuffer
   // variable, the address of which is passed into the function.  The
   // function's parameter is not NULL, so the function will not attempt any
   // dynamic memory allocation, and therefore the function will not return
   // return NULL.
   xSemaphore = sem\_binary\_create( \&xSemaphoreBuffer );

   // Rest of task code goes here.
\}
\end{DoxyPre}
 