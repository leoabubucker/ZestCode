\doxysection{x\+Queue\+Receive\+From\+ISR}
\hypertarget{group__x_queue_receive_from_i_s_r}{}\label{group__x_queue_receive_from_i_s_r}\index{xQueueReceiveFromISR@{xQueueReceiveFromISR}}
queue. h 
\begin{DoxyPre}
int32\_t xQueueReceiveFromISR(                                    queue\_t  xQueue,                                    void *pvBuffer,                                    int32\_t *pxTaskWoken                                );
  \end{DoxyPre}


Receive an item from a queue. It is safe to use this function from within an interrupt service routine.


\begin{DoxyParams}{Parameters}
{\em x\+Queue} & The handle to the queue from which the item is to be received.\\
\hline
{\em pv\+Buffer} & Pointer to the buffer into which the received item will be copied.\\
\hline
{\em px\+Task\+Woken} & A task may be blocked waiting for space to become available on the queue. If x\+Queue\+Receive\+From\+ISR causes such a task to unblock \texorpdfstring{$\ast$}{*}px\+Task\+Woken will get set to pd\+TRUE, otherwise \texorpdfstring{$\ast$}{*}px\+Task\+Woken will remain unchanged.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pd\+TRUE if an item was successfully received from the queue, otherwise pd\+FALSE.
\end{DoxyReturn}
Example usage\+: 
\begin{DoxyPre}

queue\_t xQueue;

// Function to create a queue and post some values.
void vAFunction( void *pvParameters )
\{
char cValueToPost;
const uint32\_t xTicksToWait = ( uint32\_t )0xff;

   // Create a queue capable of containing 10 characters.
   xQueue = queue\_create( 10, sizeof( char ) );
   if( xQueue == 0 )
   \{
    // Failed to create the queue.
   \}

   // ...

   // Post some characters that will be used within an ISR.  If the queue
   // is full then this task will block for xTicksToWait ticks.
   cValueToPost = 'a';
   xQueueSend( xQueue, ( void * ) \&cValueToPost, xTicksToWait );
   cValueToPost = 'b';
   xQueueSend( xQueue, ( void * ) \&cValueToPost, xTicksToWait );

   // ... keep posting characters ... this task may block when the queue
   // becomes full.

   cValueToPost = 'c';
   xQueueSend( xQueue, ( void * ) \&cValueToPost, xTicksToWait );
\}

// ISR that outputs all the characters received on the queue.
void vISR\_Routine( void )
\{
int32\_t xTaskWokenByReceive = pdFALSE;
char cRxedChar;

   while( xQueueReceiveFromISR( xQueue, ( void * ) \&cRxedChar, \&xTaskWokenByReceive) )
   \{
    // A character was received.  Output the character now.
    vOutputCharacter( cRxedChar );

    // If removing the character from the queue woke the task that was
    // posting onto the queue cTaskWokenByReceive will have been set to
    // pdTRUE.  No matter how many times this loop iterates only one
    // task will be woken.
   \}

   if( cTaskWokenByPost != ( char ) pdFALSE;
   \{
    taskYIELD ();
   \}
\}
\end{DoxyPre}
 