\doxysection{mutex\+\_\+recursive\+\_\+take}
\hypertarget{group__mutex__recursive__take}{}\label{group__mutex__recursive__take}\index{mutex\_recursive\_take@{mutex\_recursive\_take}}
semphr. h \doxylink{group__c-rtos_ga67f8421ccecb58c807762494efe10c3a}{mutex\+\_\+recursive\+\_\+take(                            sem\+\_\+t x\+Mutex,                            uint32\+\_\+t x\+Block\+Time                          )}

{\itshape Macro} to recursively obtain, or \textquotesingle{}take\textquotesingle{}, a mutex type semaphore. The mutex must have previously been created using a call to \doxylink{group__c-rtos_gab32c3cf41f7dbde49dfac10c279347f0}{mutex\+\_\+recursive\+\_\+create()};

config\+USE\+\_\+\+RECURSIVE\+\_\+\+MUTEXES must be set to 1 in \doxylink{_free_r_t_o_s_config_8h_source}{Free\+RTOSConfig.\+h} for this macro to be available.

This macro must not be used on mutexes created using \doxylink{group__c-rtos_ga475d096afa3abcc9a276ca9fa54bafdf}{mutex\+\_\+create()}.

A mutex used recursively can be \textquotesingle{}taken\textquotesingle{} repeatedly by the owner. The mutex doesn\textquotesingle{}t become available again until the owner has called \doxylink{group__c-rtos_gaaf82d93cd652b6173372970018fdc02d}{mutex\+\_\+recursive\+\_\+give()} for each successful \textquotesingle{}take\textquotesingle{} request. For example, if a task successfully \textquotesingle{}takes\textquotesingle{} the same mutex 5 times then the mutex will not be available to any other task until it has also \textquotesingle{}given\textquotesingle{} the mutex back exactly five times.


\begin{DoxyParams}{Parameters}
{\em x\+Mutex} & A handle to the mutex being obtained. This is the handle returned by \doxylink{group__c-rtos_gab32c3cf41f7dbde49dfac10c279347f0}{mutex\+\_\+recursive\+\_\+create()};\\
\hline
{\em x\+Block\+Time} & The time in ticks to wait for the semaphore to become available. The macro port\+TICK\+\_\+\+PERIOD\+\_\+\+MS can be used to convert this to a real time. A block time of zero can be used to poll the semaphore. If the task already owns the semaphore then \doxylink{group__c-rtos_ga67f8421ccecb58c807762494efe10c3a}{mutex\+\_\+recursive\+\_\+take()} will return immediately no matter what the value of x\+Block\+Time.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pd\+TRUE if the semaphore was obtained. pd\+FALSE if x\+Block\+Time expired without the semaphore becoming available.
\end{DoxyReturn}
Example usage\+: 
\begin{DoxyPre}
sem\_t xMutex = NULL;

// A task that creates a mutex.
void vATask( void * pvParameters )
\{
   // Create the mutex to guard a shared resource.
   xMutex = \doxylink{group__c-rtos_gab32c3cf41f7dbde49dfac10c279347f0}{mutex\_recursive\_create()};
\}

// A task that uses the mutex.
void vAnotherTask( void * pvParameters )
\{
   // ... Do other things.

   if( xMutex != NULL )
   \{
       // See if we can obtain the mutex.  If the mutex is not available
       // wait 10 ticks to see if it becomes free.
       if( mutex\_recursive\_take( xSemaphore, ( uint32\_t ) 10 ) == pdTRUE )
       \{
           // We were able to obtain the mutex and can now access the
           // shared resource.

           // ...
           // For some reason due to the nature of the code further calls to
           // \doxylink{group__c-rtos_ga67f8421ccecb58c807762494efe10c3a}{mutex\_recursive\_take()} are made on the same mutex.  In real
           // code these would not be just sequential calls as this would make
           // no sense.  Instead the calls are likely to be buried inside
           // a more complex call structure.
           mutex\_recursive\_take( xMutex, ( uint32\_t ) 10 );
           mutex\_recursive\_take( xMutex, ( uint32\_t ) 10 );

           // The mutex has now been 'taken' three times, so will not be
           // available to another task until it has also been given back
           // three times.  Again it is unlikely that real code would have
           // these calls sequentially, but instead buried in a more complex
           // call structure.  This is just for illustrative purposes.
           mutex\_recursive\_give( xMutex );
           mutex\_recursive\_give( xMutex );
           mutex\_recursive\_give( xMutex );

           // Now the mutex can be taken by other tasks.
       \}
       else
       \{
           // We could not obtain the mutex and can therefore not access
           // the shared resource safely.
       \}
   \}
\}
\end{DoxyPre}


semphr. h \doxylink{group__c-rtos_ga67f8421ccecb58c807762494efe10c3a}{mutex\+\_\+recursive\+\_\+take(                            sem\+\_\+t x\+Mutex,                            uint32\+\_\+t x\+Block\+Time                          )}

{\itshape Macro} to recursively obtain, or \textquotesingle{}take\textquotesingle{}, a mutex type semaphore. The mutex must have previously been created using a call to \doxylink{group__c-rtos_gab32c3cf41f7dbde49dfac10c279347f0}{mutex\+\_\+recursive\+\_\+create()};

config\+USE\+\_\+\+RECURSIVE\+\_\+\+MUTEXES must be set to 1 in \doxylink{_free_r_t_o_s_config_8h_source}{Free\+RTOSConfig.\+h} for this macro to be available.

This macro must not be used on mutexes created using \doxylink{group__c-rtos_ga475d096afa3abcc9a276ca9fa54bafdf}{mutex\+\_\+create()}.

A mutex used recursively can be \textquotesingle{}taken\textquotesingle{} repeatedly by the owner. The mutex doesn\textquotesingle{}t become available again until the owner has called \doxylink{group__c-rtos_gaaf82d93cd652b6173372970018fdc02d}{mutex\+\_\+recursive\+\_\+give()} for each successful \textquotesingle{}take\textquotesingle{} request. For example, if a task successfully \textquotesingle{}takes\textquotesingle{} the same mutex 5 times then the mutex will not be available to any other task until it has also \textquotesingle{}given\textquotesingle{} the mutex back exactly five times.


\begin{DoxyParams}{Parameters}
{\em x\+Mutex} & A handle to the mutex being obtained. This is the handle returned by \doxylink{group__c-rtos_gab32c3cf41f7dbde49dfac10c279347f0}{mutex\+\_\+recursive\+\_\+create()};\\
\hline
{\em x\+Block\+Time} & The time in ticks to wait for the semaphore to become available. The macro port\+TICK\+\_\+\+PERIOD\+\_\+\+MS can be used to convert this to a real time. A block time of zero can be used to poll the semaphore. If the task already owns the semaphore then \doxylink{group__c-rtos_ga67f8421ccecb58c807762494efe10c3a}{mutex\+\_\+recursive\+\_\+take()} will return immediately no matter what the value of x\+Block\+Time.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pd\+TRUE if the semaphore was obtained. pd\+FALSE if x\+Block\+Time expired without the semaphore becoming available.
\end{DoxyReturn}
Example usage\+: 
\begin{DoxyPre}
sem\_t xMutex = NULL;

// A task that creates a mutex.
void vATask( void * pvParameters )
\{
   // Create the mutex to guard a shared resource.
   xMutex = \doxylink{group__c-rtos_gab32c3cf41f7dbde49dfac10c279347f0}{mutex\_recursive\_create()};
\}

// A task that uses the mutex.
void vAnotherTask( void * pvParameters )
\{
   // ... Do other things.

   if( xMutex != NULL )
   \{
       // See if we can obtain the mutex.  If the mutex is not available
       // wait 10 ticks to see if it becomes free.
       if( mutex\_recursive\_take( sem, ( uint32\_t ) 10 ) == pdTRUE )
       \{
           // We were able to obtain the mutex and can now access the
           // shared resource.

           // ...
           // For some reason due to the nature of the code further calls to
                       // \doxylink{group__c-rtos_ga67f8421ccecb58c807762494efe10c3a}{mutex\_recursive\_take()} are made on the same mutex.  In real
                       // code these would not be just sequential calls as this would make
                       // no sense.  Instead the calls are likely to be buried inside
                       // a more complex call structure.
           mutex\_recursive\_take( xMutex, ( uint32\_t ) 10 );
           mutex\_recursive\_take( xMutex, ( uint32\_t ) 10 );

           // The mutex has now been 'taken' three times, so will not be
                       // available to another task until it has also been given back
                       // three times.  Again it is unlikely that real code would have
                       // these calls sequentially, but instead buried in a more complex
                       // call structure.  This is just for illustrative purposes.
           mutex\_recursive\_give( xMutex );
                       mutex\_recursive\_give( xMutex );
                       mutex\_recursive\_give( xMutex );

                       // Now the mutex can be taken by other tasks.
       \}
       else
       \{
           // We could not obtain the mutex and can therefore not access
           // the shared resource safely.
       \}
   \}
\}
\end{DoxyPre}
 